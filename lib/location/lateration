import 'dart:math';

import '/data/beacons.dart';
import '/models/beacon.dart';
import '/models/beacon_measured.dart';


/// Lateration solver for 3D anchors with a fixed tag height.
///
/// Use this when:
/// - Anchors (A, B, C, D, ...) are in 3D
/// - Distances are noisy / inconsistent (real-world sensors)
/// - The tracked object always has a fixed height (e.g. z = 1.0)
class Lateration {
  final double fixedZ;
  final int iterations;
  final double learningRate;
  const Lateration({
    this.fixedZ = 1.0,
    this.iterations = 800,
    this.learningRate = 0.03,
  });

  Point3d solve(List<BeaconMeasured> beaconMeasurements) {
    if (beaconMeasurements.length < 3) {
      throw ArgumentError('At least 3 beacon measurements are required for lateration.');
    }

    final initial = _centroid2D(beaconMeasurements);

    double x = initial.dx;
    double y = initial.dy;
    final double z = fixedZ;

    for (int i = 0; i < iterations; i++) {
      double gradX = 0.0;
      double gradY = 0.0;

      for (final beaconMeasure in beaconMeasurements) {
        final dx = x - beaconMeasure.beacon.coordinates.x;
        final dy = y - beaconMeasure.beacon.coordinates.y;
        final dz = z - beaconMeasure.beacon.coordinates.z;

        final predictedDist = sqrt(dx * dx + dy * dy + dz * dz);

        if (predictedDist == 0) continue;

        final error = predictedDist - beaconMeasure.distance;

        gradX += (error * dx) / predictedDist;
        gradY += (error * dy) / predictedDist;
      }

      x -= learningRate * gradX;
      y -= learningRate * gradY;
    }

    return Point3d(x, y, z);
  }

  /// Optional: weighted solve (better for noisy sensors like UWB/RSSI)
  /// Higher weight = more trusted anchor
  /*List<double> solveWeighted(
    List<Anchor3D> anchors,
    List<double> weights,
  ) {
    if (anchors.length != weights.length) {
      throw ArgumentError('Anchors and weights must have the same length.');
    }

    if (anchors.length < 3) {
      throw ArgumentError('At least 3 anchors are required for lateration.');
    }

    final initial = _centroid2D(anchors);

    double x = initial.dx;
    double y = initial.dy;
    final double z = fixedZ;

    for (int i = 0; i < iterations; i++) {
      double gradX = 0.0;
      double gradY = 0.0;

      for (int j = 0; j < anchors.length; j++) {
        final anchor = anchors[j];
        final weight = weights[j];

        final dx = x - anchor.x;
        final dy = y - anchor.y;
        final dz = z - anchor.z;

        final predictedDist = sqrt(dx * dx + dy * dy + dz * dz);

        if (predictedDist == 0) continue;

        final error = predictedDist - anchor.distance;

        gradX += weight * (error * dx) / predictedDist;
        gradY += weight * (error * dy) / predictedDist;
      }

      x -= learningRate * gradX;
      y -= learningRate * gradY;
    }

    return [x, y, z];
  }*/

  Point _centroid2D(List<BeaconMeasured> beaconMeasurements) {
    double sumX = 0.0;
    double sumY = 0.0;

    for (final beaconMeasured in beaconMeasurements) {
      sumX += beaconMeasured.beacon.coox;
      sumY += beaconMeasured.y;
    }

    return Point(sumX / beaconMeasurements.length, sumY / beaconMeasurements.length);
  }
}

/// Example usage inside Flutter / Dart:
///
/// final lateration = Lateration(fixedZ: 1.0);
///
/// final anchors = [
///   Anchor3D(x: 0, y: 0, z: 2.5, distance: 4.2),
///   Anchor3D(x: 10, y: 0, z: 2.0, distance: 6.1),
///   Anchor3D(x: 5, y: 8, z: 2.2, distance: 5.0),
///   Anchor3D(x: 8, y: 6, z: 3.0, distance: 4.8),
/// ];
///
/// final position = lateration.solve(anchors);
/// print(position);
